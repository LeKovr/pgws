h1. Поддержка оперативных данных

{{toc}}

Текущая реализация исходит из того, что оперативные данные находятся вне PGWS (в других схемах БД) и в рамках PGWS только используются, но никак не управляются.

Далее рассматривается вопрос управления такими данными.

h2. 1. Суть вопроса

*Оперативные данные* - это некоторые таблицы, которые

# Содержат данные, создаваемые в процессе эксплуатации системы
# Не допускают потерю данных (в т.ч. при изменении структуры)
# Являются основой для формирования минимальных по размеру резервных копий (все, кроме этих данных, есть в git)

h2. 2. Возможные модели

h3. 2.1. Хрупкая модель

В этом случае считается, что удаление какого-либо объекта может повлечь инвалидацию всей схемы данных и единственным способом изменения структуры таблиц принимается _ALTER TABLE_. Такая модель имеет следующие особенности:

# Полный дамп всей БД - единственный вариант резервной копии
# Обновление (пакет изменений структуры, хранимого кода и т.п.) атомарно, между обновлениями система должна быть полностью работоспособна

Следствия:

# Для того, чтобы версию N обновить до версии N + X, необходимо последовательно выполнить обновления 1..Х (включая обновление данных и хранимого кода)
# Если обновление включает изменение хранимого кода, оно должно содержать полные определения изменяемых функций
# Актуальная версия любой хранимой функции доступна только в БД или в последнем обновлении, которое ее включало
# Вынесение обновлений в отдельные файлы/каталоги не позволяет использовать СКВ (например, git) для контроля изменений исходного кода

Т.о., для проектов с большим количеством хранимого кода, существенной проблемой такой модели становится поиск баланса между механизмом обновлений и контролем версий хранимого кода.

h3. 2.2. Эластичная модель

В этой модели БД оперативные данные отделяются от всего остального (программной части, включающей хранимый код и данные, которые меняются только в процессе модернизации БД). При этом программная часть (ПЧ) организована так, что

# Удаление и повторное создание ПЧ не меняет общей валидности БД
# Обновление БД с версии N до N + X представляет собой удаление ПЧ, последоватальное обновление ОД до N + X и создание ПЧ версии N + X
# Актуальная версия любой хранимой функции всегда хранится в одном и том же файле
# В СКВ без истории хранятся только команды обновления ОД (они привязаны к номеру обновления)

Далее рассмотрим гипотезу о том, что эластичная модель может быть применима на практике.

h2. 3. Эластичная модель

h3. 3.1. Варианты размещения ОД

1. Одна схема для всех пакетов.
Минусы: вопросы создания/удаления/резервирования данных пакета надо будет решать потаблично, настройку связей после создания - попакетно
Плюсы: вопрос создания схемы надо будет решать один раз, дамп этой схемы - это полный дамп всего необходимого

2. Для каждого пакета - своя схема данных постоянного хранения
Минусы: надо отдельно отслеживать связи между такими таблицами для разных пакетов (например, посты вики и пользователи)
Плюсы: уже реализован контроль зависимостей на уровне пакетов и логично развивать его, а не добавлять потабличные зависимости.

Т.о., первоначально выберем в качестве основного враиант 2.

h3. 3.2. Особенности реализации

h4. 3.2.1. Первоначальное создание схемы БД

Отличие первоначального создания схемы БД от последующих в том, что еще нет структур ОД. Т.е. необходимо определить этот факт и создать их.
При этом ПЧ в этот момент имеет актуальную версию, а не первоначальную. Т.е. надо выбрать один из двух вариантов:

# В составе ПЧ хранится первоначальная версия DDL ОД и, при необходимости создания схем ОД сначала создается первоначальная версия, потом производится обновление ОД до актуальной версии
# В составе ПЧ хранится актуальная версия DDL ОД и код обновления используется только при обновлении уже существующих схем ОД

*Текущее состояние*:

# Если у пакета NAME есть ОД, они хранятся в схеме NAME_data и только там
# Первоначальная версия DDL ОД размещается в файле *19_NAME_data.sql* (где NAME - имя пакета)
# При создании ПЧ проверяется наличие схемы *NAME_data*, если она есть - копия файла 19_NAME_data.sql очищается

h4. 3.2.2. Удаление ПЧ

При удалении ПЧ должны удаляться все связи с ОД (триггеры, внешние ключи и т.п.) и при создании восстанавливаться заново.
Для целей разработки также должно быть предусмотрено удаление ОД отдельной командой.

*Текущее состояние*:

# Перед полным удалением схемы данных ПЧ, выполняется файл *00_cleanup.sql*, в котором должно производиться удаление всех связей с ОД
# Команда *pgws.sh db drop ...* удаляет только ПЧ, для удаления ОД необходимо выполнять *pgws.sh db dropdata*

h4. 3.2.3. Резервные копии

Резервная копия - это дамп ОД + ПЧ соответствующей версии. Следовательно, в составе ОД должна быть информация о соответствующих версиях пакетов ПЧ и она должна быть учтена при восстановлении.

*Текущее состояние*:

# В схеме *ws_data* есть таблица *pkg_data*, в которой хранятся версии всех схем ОД
# Команда *pgws.sh db dumpdata* сохраняет дамп всех схем *_data в отдельный архив (dbdump-KEY.tar.gz)
# Команда *pgws.sh db restoredata KEY* восстанавливает все ОД в пустой БД, после этого ПЧ создается стандартным *db init ...*


h2. 4. Текущие вопросы

# Вариант из п. 3.2.1. Хранить первичную версию DDL ОД или актуальную?
# Таблицы ОД не используют типы PGWS, однако методы PGWS могут возвращать структуры, совпадающие с таблицами. Для документирования и улучшения разграничения ответственности, не стоит ли для каждой таблицы ОД в рамках PGWS создавать одноименное представление с конверсией типов и возвращать уже его?

h2. TODO

Описание проблемы:

В состав подсистемы могут входить оперативные таблицы и справочники, редактируемые пользователем. Например, для системы авторизации этими данными могут быть: группы пользователей и сами пользователи. В зависимости от условий поставки, эти данные изначально могут быть либо заполнены большим количеством данных, либо вовсе пустыми.
Связи для работы с этими таблицами не выходят за пределы подсистемы
В процессе работы пользователь накапливает свои рабочие данные в этих таблицах. Эти данные являются первичными.
Проблема:
При выбранной методике работы необходимо каким-то образом сохранить данные, введенные пользователем перед дальнейшим обновлением базы данных. Затем эти данные нужно вернуть обратно.
