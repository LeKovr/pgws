h1. Описание реализации

{{toc}}

h2. Введение

PGWS (PostGresql WebServices) предназначен для решения следующих задач:

# Предоставить внутренней команде разработчиков эффективный инструмент текущего сопровождения действующей системы на период до внедрения новой версии системы, т.е. до замены текущих подсистем новыми
# Предоставить средство быстрого прототипирования планируемых интерфейсов с возможностью переноса части полученного кода (sql и js) в новую версию системы

По факту реализации, PGWS -это способ сделать один набор методов и единообразно вызывать их при построении html, из javascript и из внешних клиентских программ.

Методы создаются как хранимые процедуры на sql, plpgsql (или другом встроенном языке Postgresql) или как плагины на perl. После регистрации метода, в PGWS становится доступен как его непосредственный вызов, так и документация по методу, включающая описание метода, аргументов, результата и настроек доступа.

Ниже приводится описание реализации. Программная реализация использует perl (~1100 строк исходного кода) и sql/plpgsql (~1600 строк исходного кода, DDL и данных)

h3. Особенности реализации (потенциальные плюсы)

h4. Единый протокол доступа к чтению и изменению данных

При разработке html-интерфейса используются те же методы, которые доступны внешнему клиентскому ПО и клиентам на javascript. Разработчики интефейсов используют единое API по стандартному протоколу (в случае сетевого обмена), что позволяет разрабатывать любой интерфейс, в т.ч. html-интерфейс сайта проекта, силами внешних команд и упрощает изучение доступного функционала, не раскрывая при этом бизнес-логику проекта.

Использование JSON-RPC в качестве стандартного протокола сетевого обмена позволяет разрабатывать и серверную и клиентскую части независимо друг от друга на любой програмной платформе. В частности, и серверное и клиентское ПО может быть в будущем заменено на какое-либо другое (с тем же функционалом) прозрачно для второй стороны обмена.

Для того, чтобы разработка серверной части не задерживала реализацию клиентской, на сервере предусмотрен режим эмуляции работы с БД, при котором результаты вызова методов не запрашиваются в БД, а загружаются из текстовых файлов в кэш, после чего доступны клиентам идентично результатам реальных методов API, которые в этот момент еще могут быть не реализованы.

В числе задач для внутренней команды разработчиков остается только бизнес-логика - операции чтения и изменения данных проекта.

Для снижения затрат внутренней команды предусмотрено автоматическое документирование создаваемых методов API в формате, позволяющем публикацию всей необходимой информации как в рамках сайта проекта (на языке целевой аудитории), так и в форматах межпрограммного обмена (WSDL(т.е SOAP ), SMD и т.п.).

Для снижения затрат внешних команд реализована передача параметров отладки вызове метода и возврат в ответе журнала выполнения метода сервером.

h4. Единая система разграничения доступа

В проекте реализована система разграничения доступа к методам API, которая интегрирована в текущую систему разграничения доступа действующего проекта и позволяет дополнительно:

# публикацию всех существующих методов API, в т.ч. требующих системную авторизацию, без снижения уровня безопасности системы
# реализацию веб-интерфейса настройки доступа к методам API и функциональным элементам интерфейса и его использование без привлечения разработчиков серверной и интерфейсной части

h4. Отсутствие генерируемого кода

В отличие от практики генерации программного кода по некоторой конфигурации, в проекте все метаданные представлены в таблицах БД, что позволяет как снизить общий объем исходного кода проекта, так и упростить его сопровождение, т.к. соответствие данных заданным требованиям проще гарантировать и обеспечить, чем аналогичные задачи для программного кода.

Размещение такой информации, как список доступных методов, описание их аргументов и разграничения доступа, в таблицах БД позволяет управлять ею стандартными средствами БД через интерактивные интерфейсы и, как и другие данные, переносить в кэш при первом обращении. Данные занимают меньше места, чем сформированный по ним (и скомпиллированный код), поэтому кэш метаданных допускает постоянное хранение в ОЗУ сервера. В частности, кэш метаданных описания 90 методов API в формате JSON занимает ~ 400КБайт. Эти данные не изменяются в процессе эксплуатации релиза (т.е. между обновлениями) и могут храниться в постоянном кэше, т.о. их хранение в БД фактически не увеличивает нагрузку на нее.

h4. Небольшой объем серверного кода

Трудоемкость будущего сопровождения и доработки проекта можно оценить по следующим значениям:

# Основная часть программной реализации проекта - библиотека PWL::Server. В версии от 28.06.2010 это *443* строки кода (без учета комментариев и команд отладки). 
# Фронтенд, который отвечает за формирование html-страниц и передачу серверу запросов к API - *76* строк кода (без учета комментариев и команд отладки)
# Хранимый в БД код (sql и plpgsql) ядра системы (без прикладной логики) - *800* строк кода
# Общий объем кода на perl - *~1100* строк
# Общий объем sql/plpgsql кода, данных и команд создания объектов БД - *~1600* строк 

Т.к. речь идет о рабочей версии проекта, можно сделать вывод, что основная часть затрат на его эксплуатацию будет в части прикладной логики, а ядро системы не потребует существенных затрат даже в случае его реализации на другой программной платформе.

Эта часть проекта (ядро) полностью функциональна, не имеет отношения к коду или структурам данных текущей системы, не содержит коммерческой информации и может быть опубликована для привлечения opensource-сообщества к ее использованию и улучшению.

h4. Ограниченное количество структурных элементов

Рассматриваемое решение состоит из 4х структурных элементов:

# клиентский код на javascript 
# шаблоны html-страниц 
# ядро (Фронтенд и Сервер)
# БД (код и данные)

Критичными для функционирования системы являются два последних блока в этом списке. Очевидно, что чем меньше самостоятельных подсистем используется в процессе работы системы, тем надежнее и проще в эксплуатации их взаимодействие. В данном случае задачу вертикальной стыковки компонентов системы можно считать решенной оптимально. При этом первые три элемента не содержат никаких данных (кроме кэша в ядре) и не имеют ограничений по числу запускаемых копий и серверов размещения, а задача обеспечения надежности и горизонтальной масштабируемости возлагается на элемент, для которого ее в любом случае решать необходимо - на БД.

h4. Минимальные требования архитектуры к программным платформам

Архитектура системы предъявляет к программной реализации следующие требования:

# данные для построения html-страниц получаются посредством вызова методов по протоколу JSON-RPC или обращением к коду, осуществляющему такие вызовы
# запрос на изменение данных (в html-форме) получает в ответ структуру данных, а не html
# используемая СУБД поддерживает:
## триггеры и хранимые процедуры
## системный каталог (доступ к информации о хранимых процедурах, типах данных, таблицах)
## пользовательские типы данных (опционально)
## обработку исключений (опционально)

Любая программная платформа (или комплекс платформ), удовлетворяющая этим требованиям, может быть использована для реализации описываемого проекта.
Решение на основе *perl* и *postgresql* реализовано первым по причине наличия разработчика необходимой квалификации с итоговой оценкой трудозатрат ~ 500 человекочасов, включая проектирование.
В текущем состоянии проект может быть использован для разработки бизнес-логики и интерфейсов как для эксплуатации на боевой системе, так и для прототипирования новых интерфейсных и функциональных решений для подготовки и уточнения технических заданий на последующую доработку системы.

h4. Эффективное использование возможностей СУБД

Современные системы управления реляционными базами данных (СУБД) задачи хранения данных и предоставления к ним доступа решают еще с прошлого тысячелетия. За эти годы реализовано много функционала для решения задач, возникающих при работе с данными. И сейчас, в некоторых ситуациях, использование СУБД только для хранения равносильно забиванию гвоздей микроскопом
При том, что СУБД - критичная часть любой информационной системы, использовать ее только для хранения не всегда оптимально. В этом случае, скорее всего, придется разрабатывать (и оплачивать) функционал, который не только ранее реализован, но и доступен в рамках уже используемого программного продукта. Это, конечно, определяется задачами бизнеса. "Независимость от СУБД" может окупиться на коробочном продукте, но с меньшей вероятностью - на эксклюзивном сетевом ресурсе. 
Изложенное в данном разделе основано на предположении, что основной бизнес компании - это именно эксклюзивный сетевой ресурс, а поддержка альтернативных СУБД не включена в основной бюджет, но, возможно, запланирована в затратах как процент от прибыли.

h5. Размещение бизнес-логики в хранимом коде БД

Наиболее эффективный способ гарантировать целостность данных - исключить изменение данных без контроля программным кодом. Это значит, что хранимый код неизбежен. Остается вопрос о том, какая часть всего программного кода должна быть размещена в БД. 
Реализация проекта основана на следующих утверждениях:

# Код, который в рамках БД реализовывается не менее эффективно, чем в других слоях решения - реализовывается в рамках БД (включая код, отвечающий за целостность данных)
# Код, для которого БД менее эффективна - реализовывается как внешний

Кроме прочего, в проекте реализована технология установки хранимого кода, при которой ошибка базового теста влечет откат всех изменений, включая  не только код, но и данные. 

h5. Разделение всех запросов к БД на читающие и пишущие

В общем случае, по тексту SQL запроса нельзя определить, изменяет ли он данные в БД. Решение этой задачи - ответственность разработчика БД, что реализовано в проекте требованием задавать факт изменения данных при регистрации метода. В результате про любое обращение к БД заранее известно, меняет ли оно данные и, оответственно, должно ли оно быть отправлено на основной экземпляр БД или на реплики.

h5. Наличие универсального интерфейса к данным и бизнес-логике

Основная ценность любого проекта - данные. В процессе эксплуатации могут возникать непредсказуемые задачи по их анализу и исправлению. 
Хранение данных в БД имеет плюсом возможность универсального доступа к этим данным посредством стандартных интерфейсов (sqlplus, psql, mysqladmin и т. п.). Возможности администрирования через такие интерфейсы по данным не ограничены, они ограничиваются лишь тем, какая часть бизнес-логики доступна в БД. Размещение кода бизнес-логики в БД позволяет в процессе эксплуатации системы стандартным и универсальным способом оперировать не только данными, но и связанным с ними функционалом. Например - по сложному уникальному критерию оперативно создать задачи на рассылку уведомлений или откатить ошибочные изменения.

Если исходить из того, что любое программное решение будет хранить данные в БД, то оно автоматичесик будет иметь доступ и к коду, размещенному в БД. При этом доступ к коду самого програмного решения такого универсального интерфейса или иметь не будет или он потребует дополнительных затрат относительно того, что уже и так есть.

h2. Структурная схема прототипа

!ws_flow.png!
рис 1. Схема взаимодействия модулей программного интерфейса и внешних клиентов.

Прототип программного интерфейса реализован в виде двух модулей - Фронтенд и Сервер.

h2. Фронтенд

Часть веб-сервера, через которую происходит взаимодействие с API PWL. Может быть включен в действующую систему в режимах CGI, Apache::PerlRun, mod_perl.

Предназначен для решения задач:

# Взаимодействие с внешним ПО (получение запросов к методам API, обмен с сервером, формирование ответов)
# Формирование html-страниц (обработка запросов браузера, предоставление шаблонизатору доступа к API)

h3. Алгоритм обработки запросов Фронтендом

h4. POST запрос application/json

Такой запрос означает вызов клиентом метода API по протоколу JSON-RPC. Он дополняется атрибутами вызывающей стороны (ip) и передается серверу. Ответ cервера (данные в конверте JSON-RPC) возвращается клиенту в формате JSON.

h4. POST или GET запрос к адресу /_*

Такой запрос означает вызов клиентом метода API по протоколу REST. Имя метода берется из URI (/_name -> name), дополняется атрибутами вызывающей стороны (sid валидируется отдельным запросом) и передается серверу. Ответ сервера возвращается клиенту в формате JSON (без конверта JSON-RPC)

h4. GET запрос

Запрос на получение HTML-страницы. У Сервера запрашиваются валидность sid, атрибуты страницы, соответствующей URI запроса, и права доступа клиента к этой странице. После этого вызывается шаблонизатор, который формирует страницу. Страница передается клиенту. 

h4. API запрос

Для формирования страниц используется шаблонизатор TemplateToolkit, для которого реализована возможность вызова методов API. Такой вызов конвертируется в запрос серверу и полученный ответ возвращается в шаблонизатор в виде структуры данных.

Подробнее: [[rpc|протокол передачи данных]]

h2. Сервер

Предназначен для непосредственной реализации методов программного интерфейса. Все доступные методы реализованы как плагины к Серверу или как вызываемые Сервером хранимые процедуры БД.

Сервер решает задачи:

# отображения публичных идентификаторов методов во внутренние
# проверки прав доступа
# валидации аргументов 
# кэширования результатов вызова методов

h3. Алгоритм обработки запросов Сервером

# Распарсить JSON, проверить корректность формата и валидность sid (для случая JSON-RPC запроса)
# Получить из БД атрибуты запрошенного метода
# Проверить права доступа клиента на вызов метода (провести валидацию аргументов, идентифицирующих объект)
# Провести валидацию остальных аргументов запроса
# Извлечь результат вызова метода из кэша или вызвать метод (и сохранить результат в кэш)
# Сформировать структуру ответа (с результатами метода или описанием ошибок)
# Добавить JSON-RPC конверт ответ (для случая JSON-RPC запроса)
# Вернуть ответ фронтенду

Клиенты взаимодействуют с Фронендом по протоколу JSON-RPC 2.0 over HTTP. 

В первоначальной версии Сервер используется Фронтендом как подключаемая библиотека с двумя публичными методами (выполнить запрос клиента и выполнить внутренний запрос Фронтенда). В будущем эти методы будут вызываться Фронтендом по протоколу JSON-RPC (или ICE?).

h2. Схема данных

!ws_main.png!
рис 2. Схема данных прототипа

h3. Разграничение доступа

Разграничение доступа - замкнутая подсистема PWL, которая основана на следующей модели:

# Каждый объект может иметь несколько состояний,
# Для каждого из состояний объекта задан список возможных акций над объектом
# Для каждой акции задан список разрешенных ролей
# Каждый метод соответствует некоторой акции

Т.о., разрешение выполнить метод определяется тройкой значений:
# Текущий статус объекта, над которым выполняется метод
# Акция, которой соответствует метод
# Уровень доступа пользователя, запросившего выполнение метода

Подробнее: [[acl|Разграничение доступа]]

h3. Типы данных и правила валидации

Типы данных и правила валидации - замкнутая подсистема PWL, которая используется в описании методов (типа аргументов и типа результатов метода).

По данным подсистемы производится:
# проверка соответствия заданным условиям аргументов вызываемых методов
# автодокументирование аргументов и результатов вызываемых методов

Подробнее: [[typesystem|Типы данных и правила валидации]]

h3. Данные API

Функционал PWL основан на данных двух основных таблиц БД - *method* и *page*. Все остальные таблицы предназначены для реализации функционала именно в том виде, как это было задумано при изначальном проектировании.

h4. method

Реестр методов API. Регистрация метода производится добавлением строки в эту таблицу. Атрибуты метода включают
# внешнее и реальное имя метода
# атрибуты уровня доступа для выполнения метода (идентификаторы класса и акции)
# описание аргументов метода (идентификатор типа)
# описание результата (идентификатор типа)
# идентификатор кэша, в котором размещаются результаты вызовов метода
# пример аргументов для тестового вызова метода

h4. page

Реестр страниц HTML-интерфейса, которые поддерживает Фронтенд. Страницы организованы иерархически (все, кроме главной имеют ссылку на вышестоящую), что позволяет программно строить карту сайта. Страницы, которые имеют в адресе идентификатор объекта (или несколько) могут быть показаны в карте соответствующего подраздела (когда эти идентификаторы известны).

Атрибуты страницы включают:
# кодовое имя страницы (используется в шаблонах для формирования ссылок на страницу)
# атрибуты уровня доступа для показа страницы (идентификаторы класса и акции)
# имя шаблона страницы
# описание URI (маска для поиска в URI запроса и шаблон для построения URI по заданным идентификаторам объекта)
# порядок сортировки в карте сайта

h4. Служебные таблицы

* *error* - список кодов и описаний ошибок уровня приложения
* *method_rv_format* - справочник форматов результатов метода
* *cache* - список кэшей (конкретные параметры задаются в конфигурации сервера)
* *server* - список серверов для горизонтального масштабирования
